<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

</head>
<body>

<script>

    // console.log('asd');
    // setTimeout(function f() {
    //     console.log('timeout 1');
    // }, 1000);
    // setTimeout(function f() {
    //     console.log('timeout 2');
    // }, 500);
    // console.log('qwe');

    // спершу виконається синхронний код а тоді асинхронний,
    // тобто все виведеться у консоль у наступному порядку :
    // 1.asd  -->  2.qwe  --> 3.timeout 2  --> 4.timeout 1

    // callback hell
    // setTimeout(function f() {
    //     console.log('timeout 1');
    //     setTimeout(function f() {
    //         console.log('timeout 2');
    //         setTimeout(function f() {
    //             console.log('timeout 3');
    //             setTimeout(function f() {
    //                 console.log('timeout 4');
    //                 setTimeout(function f() {
    //                     console.log('timeout 5');
    //                     setTimeout(function f() {
    //                         console.log('timeout 6');
    //                     }, 6000);
    //                 }, 5000);
    //             }, 4000);
    //         }, 3000);
    //     }, 2000);
    // }, 1000);

    // З callback hell працювати не зручно тому є promise
    // micro task виконуються першими, macro task піля них
    // setTimeout() і setInterval() це macro task
    // Promise() це micro task

    // let promise = new Promise((resolve, reject) => {
    //     return setTimeout(function f() {
    //         let i = 0;
    //         console.log('t1', i);
    //         resolve(i); // resolve() каже що функція виконалась, і дозволяє виконатись наступній
    //         if (false) {
    //             reject('errorooor');
    //         }
    //     }, 1000);
    // }).then(i => {
    //     return new Promise((resolve) => {
    //         return setTimeout(function f() {
    //             i++;
    //             console.log('t2', i);
    //             resolve(i);
    //         }, 2000);
    //     })
    // }).then(i => {
    //         return new Promise(() => {
    //             return setTimeout(function f() {
    //                 i++;
    //                 console.log('t3', i);
    //             }, 3000);
    //         })
    //     })
    //     .catch(reason => {
    //         console.log()
    //     })

    // fetch вже має підкапотом асинхронна операція

    // Event Loop
    console.log(1);
    setTimeout(() => {
        console.log(2);
    }, 1000);
    console.log(3);
    // спершу виведеться 1 -> 3 -> 2

    // Async with CB
    // Promise
    // Promise race
    // Promise all
    // Async Await

</script>
</body>
</html>